<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of RDSbyOval</title>
  <meta name="keywords" content="RDSbyOval">
  <meta name="description" content="Generates left/right Random-Dot-Stereogram images using oval textures, not dots.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # Retinotopy --><!-- menu.html Common -->
<h1>RDSbyOval
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Generates left/right Random-Dot-Stereogram images using oval textures, not dots.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top"><pre class="comment"> Generates left/right Random-Dot-Stereogram images using oval textures, not dots.
 function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,...
                                colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)

 Generate left/right Random Dot (2 colors) Stereogram (RDS) Images based on heightfield.
 This function takes 'Hidden Surface Problem' (HSP) into account, but slower than 'RDSbyOvalFinest'
 The generated images are the same size with heightfield image.
 The procedure to generate RDS images are as below.
    1. create random dot image
    2. add disparity to the dots and generate left/right-eye images
    3. replace dots to ovals

 [input]
 heightfield : height field to generate RDS, [row,col]
               *NOTICE* the unit of the height should be cm
 dotRadius   : the radius of random dot [row,col](cm)
 dotDens     : density of the random dots, [percent(1-100,integer)]
 imgNum      : the number of images to be generated, [num]
 colors      : dot/background colors, [0-255(dot1),0-255(dot2),0-255(background)]
 ipd         : distance between left/right pupils, [cm]
 vdist       : visual distance from screen to eyes, [cm]
 pix_per_cm  : pixels per cm
 oversampling_ratio : if above 1, oversampling of heightfield &amp; disparity position
                      is conducted. [val](default,1)
 display_flag: if 1, the generated images will be displayed, [0/1]
 save_flag   : if 1, the generated images will be saved as RDS_imgs.mat, [0/1]

 [output]
 imgL        : generated image(s) for left eye, cells [row,col]
 imgR        : generated image(s) for right eye, cells [row,col]
 
 [example]
 field=CreateExpField([480,480],3,1);
 [imgL,imgR]=RDSbyOvalFinest(field,0.05,3,1,[255,0,128],6.4,50,57,1,0);

 Created: &quot;2010-04-03 14:05:21 ban&quot;
 Last Update: &quot;2019-05-17 16:21:18 ban&quot;</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top">
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="MakeFineOval.html" class="code" title="function img=MakeFineOval(imsize,color,bgcolor,bg_expand_ratio,fine_coefficient,gauss_flag,show_flag,save_flag)">MakeFineOval</a>	Genrates a beautiful oval image with an antialiasing option.</li><li><a href="RDSbyOval.html" class="code" title="function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)">RDSbyOval</a>	Generates left/right Random-Dot-Stereogram images using oval textures, not dots.</li><li><a href="RayTrace_ScreenPos_X.html" class="code" title="function x_pixels = RayTrace_ScreenPos_X(zdist_fromScreen, ipd, viewdist, eye, pix_per_cm, xpos_world)">RayTrace_ScreenPos_X</a>	Calculates the horizontal screen position (in pixels) of a point distance from the visual midline and z-distance.</li><li><a href="shuffle.html" class="code" title="function [Y,index] = shuffle(X)">shuffle</a>	Randomly sorts the input array.</li><li><a href="size_one2one.html" class="code" title="function size_one2one(im_h)">size_one2one</a>	Displays an image in true size without any scaling</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="RDSbyOval.html" class="code" title="function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)">RDSbyOval</a>	Generates left/right Random-Dot-Stereogram images using oval textures, not dots.</li><li><a href="RDSbyOvalFast.html" class="code" title="function [imgL,imgR]=RDSbyOvalFast(heightfield,dotRadius,dotDens,imgNum,colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)">RDSbyOvalFast</a>	Generates left/right Random-Dot-Stereogram images.</li></ul>
</div>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top">
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [Y,index] = shuffle(X)</a></li></ul>
</div>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,</a><span class="keyword">...</span>
0002                                colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)
0003 
0004 <span class="comment">% Generates left/right Random-Dot-Stereogram images using oval textures, not dots.</span>
0005 <span class="comment">% function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,...</span>
0006 <span class="comment">%                                colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% Generate left/right Random Dot (2 colors) Stereogram (RDS) Images based on heightfield.</span>
0009 <span class="comment">% This function takes 'Hidden Surface Problem' (HSP) into account, but slower than 'RDSbyOvalFinest'</span>
0010 <span class="comment">% The generated images are the same size with heightfield image.</span>
0011 <span class="comment">% The procedure to generate RDS images are as below.</span>
0012 <span class="comment">%    1. create random dot image</span>
0013 <span class="comment">%    2. add disparity to the dots and generate left/right-eye images</span>
0014 <span class="comment">%    3. replace dots to ovals</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% [input]</span>
0017 <span class="comment">% heightfield : height field to generate RDS, [row,col]</span>
0018 <span class="comment">%               *NOTICE* the unit of the height should be cm</span>
0019 <span class="comment">% dotRadius   : the radius of random dot [row,col](cm)</span>
0020 <span class="comment">% dotDens     : density of the random dots, [percent(1-100,integer)]</span>
0021 <span class="comment">% imgNum      : the number of images to be generated, [num]</span>
0022 <span class="comment">% colors      : dot/background colors, [0-255(dot1),0-255(dot2),0-255(background)]</span>
0023 <span class="comment">% ipd         : distance between left/right pupils, [cm]</span>
0024 <span class="comment">% vdist       : visual distance from screen to eyes, [cm]</span>
0025 <span class="comment">% pix_per_cm  : pixels per cm</span>
0026 <span class="comment">% oversampling_ratio : if above 1, oversampling of heightfield &amp; disparity position</span>
0027 <span class="comment">%                      is conducted. [val](default,1)</span>
0028 <span class="comment">% display_flag: if 1, the generated images will be displayed, [0/1]</span>
0029 <span class="comment">% save_flag   : if 1, the generated images will be saved as RDS_imgs.mat, [0/1]</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% [output]</span>
0032 <span class="comment">% imgL        : generated image(s) for left eye, cells [row,col]</span>
0033 <span class="comment">% imgR        : generated image(s) for right eye, cells [row,col]</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% [example]</span>
0036 <span class="comment">% field=CreateExpField([480,480],3,1);</span>
0037 <span class="comment">% [imgL,imgR]=RDSbyOvalFinest(field,0.05,3,1,[255,0,128],6.4,50,57,1,0);</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% Created: &quot;2010-04-03 14:05:21 ban&quot;</span>
0040 <span class="comment">% Last Update: &quot;2019-05-17 16:21:18 ban&quot;</span>
0041 
0042 <span class="comment">% --- input variable check</span>
0043 <span class="keyword">if</span> nargin&lt;1, help <a href="RDSbyOval.html" class="code" title="function [imgL,imgR]=RDSbyOval(heightfield,dotRadius,dotDens,imgNum,colors,ipd,vdist,pix_per_cm,oversampling_ratio,display_flag,save_flag)">RDSbyOval</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0044 <span class="keyword">if</span> nargin&lt;2 || isempty(dotRadius), dotRadius=[0.05,0.05]; <span class="keyword">end</span>
0045 <span class="keyword">if</span> nargin&lt;3 || isempty(dotDens), dotDens=10; <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin&lt;4 || isempty(imgNum), imgNum=1; <span class="keyword">end</span>
0047 <span class="keyword">if</span> nargin&lt;5 || isempty(colors), colors=[255,0,128]; <span class="keyword">end</span>
0048 <span class="keyword">if</span> nargin&lt;6 || isempty(ipd), ipd=6.4; <span class="keyword">end</span>
0049 <span class="keyword">if</span> nargin&lt;7 || isempty(vdist), vdist=65; <span class="keyword">end</span>
0050 <span class="keyword">if</span> nargin&lt;8 || isempty(pix_per_cm), 
0051   <span class="comment">% cm per pix</span>
0052   <span class="comment">% 1 inch = 2.54 cm, my PC's display is 1920x1200, 15.4 inch.</span>
0053   <span class="comment">% So, 15.4(inch)*2.54(cm) / sqrt(1920^2+1200^2) (pix) = XXX cm/pixel</span>
0054   cm_per_pix=15.4*2.54/sqrt(1920^2+1200^2);
0055   pix_per_cm=1/cm_per_pix;
0056 <span class="keyword">end</span>
0057 <span class="keyword">if</span> nargin&lt;9 || isempty(oversampling_ratio), oversampling_ratio=1; <span class="keyword">end</span>
0058 <span class="keyword">if</span> nargin&lt;10 || isempty(display_flag), display_flag=0; <span class="keyword">end</span>
0059 <span class="keyword">if</span> nargin&lt;11 || isempty(save_flag), save_flag=0; <span class="keyword">end</span>
0060 
0061 <span class="keyword">if</span> numel(dotRadius)==1, dotRadius=[dotRadius,dotRadius]; <span class="keyword">end</span>
0062 
0063 <span class="keyword">if</span> numel(colors)~=3
0064   error(<span class="string">'RDSbyOval requires 3colors [0-255(dot1),0-255(dot2),0-255(background)]. Check input variable.'</span>);
0065 <span class="keyword">end</span>
0066 
0067 <span class="comment">% adjust parameters for oversampling</span>
0068 <span class="keyword">if</span> oversampling_ratio~=1
0069   heightfield=imresize(heightfield,oversampling_ratio,<span class="string">'bilinear'</span>);
0070   dotDens=dotDens/oversampling_ratio;
0071   ipd=ipd*oversampling_ratio;
0072   vdist=vdist*oversampling_ratio;
0073   pix_per_cm=pix_per_cm*oversampling_ratio;
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">% --- initalize random seed</span>
0077 <span class="comment">%InitializeRandomSeed;</span>
0078 
0079 <span class="comment">% --- calculate position shifts for each value of heightfield</span>
0080 heightfield=-1*heightfield; <span class="comment">% since RayTrace_ScreenPos_X assumes the near position is minus value.</span>
0081 posL=round(<a href="RayTrace_ScreenPos_X.html" class="code" title="function x_pixels = RayTrace_ScreenPos_X(zdist_fromScreen, ipd, viewdist, eye, pix_per_cm, xpos_world)">RayTrace_ScreenPos_X</a>(heightfield,ipd,vdist,1,pix_per_cm,0));
0082 posR=round(<a href="RayTrace_ScreenPos_X.html" class="code" title="function x_pixels = RayTrace_ScreenPos_X(zdist_fromScreen, ipd, viewdist, eye, pix_per_cm, xpos_world)">RayTrace_ScreenPos_X</a>(heightfield,ipd,vdist,2,pix_per_cm,0));
0083 
0084 <span class="comment">% --- generate base dot</span>
0085 dotSize=round(dotRadius*pix_per_cm*2); <span class="comment">% radius(cm) --&gt; diameter(pix)</span>
0086 basedot=double(<a href="MakeFineOval.html" class="code" title="function img=MakeFineOval(imsize,color,bgcolor,bg_expand_ratio,fine_coefficient,gauss_flag,show_flag,save_flag)">MakeFineOval</a>(dotSize,[colors(1:2) 0],colors(3),1.2,2,1,0,0));
0087 wdot=basedot(:,:,1);     <span class="comment">% get only gray scale image (white)</span>
0088 bdot=basedot(:,:,2);     <span class="comment">% get only gray scale image (black)</span>
0089 dotalpha=basedot(:,:,4)./max(max(basedot(:,:,4))); <span class="comment">% get alpha channel value 0-1.0;</span>
0090 
0091 <span class="comment">% --- initializing</span>
0092 imgL=cell(imgNum,1);
0093 imgR=cell(imgNum,1);
0094 <span class="keyword">for</span> n=1:1:imgNum
0095   imgL{n}=colors(3)*ones(size(heightfield));
0096   imgR{n}=colors(3)*ones(size(heightfield));
0097 <span class="keyword">end</span>
0098 
0099 <span class="comment">% --- generate RDS images</span>
0100 <span class="keyword">for</span> n=1:1:imgNum
0101 
0102   <span class="comment">% create initial random dot image</span>
0103   randXY=randi(round(oversampling_ratio*100/dotDens),size(heightfield));
0104   randXY(randXY~=round(oversampling_ratio*100/dotDens))=0;
0105   randXY(logical(randXY))=1;
0106   <span class="comment">%randXY(randXY==0)=colors(3); % background;</span>
0107   idxs=find(randXY==1);
0108   
0109   <span class="comment">% create ID field</span>
0110   <span class="comment">% prevent ovals' overlapping problem</span>
0111   idxs=<a href="shuffle.html" class="code" title="function [Y,index] = shuffle(X)">shuffle</a>(idxs);
0112   idXY=NaN*ones(size(randXY));
0113   <span class="comment">%for ii=1:1:size(row,1), idXY(row(ii),col(ii))=idx(ii); end % much faster than using sub2ind</span>
0114   idXY(idxs)=1:size(idxs);
0115   
0116   <span class="comment">%% left image(s)</span>
0117   tmp=NaN*ones(size(randXY));
0118   hiddensurf=ones(size(randXY));
0119   pos=unique(posL(~isnan(posL)))';
0120   <span class="keyword">for</span> k = pos <span class="comment">% from near to far % min(min(posL)):max(max(posL))</span>
0121     <span class="keyword">if</span> k&lt;0
0122       level = size(randXY,2)+k;
0123       TT = [idXY(:,level+1:end) idXY(:,1:level)];
0124     <span class="keyword">elseif</span> k&gt;0
0125       level = k;
0126       TT = [idXY(:,level+1:end) idXY(:,1:level)];
0127     <span class="keyword">elseif</span> k==0
0128       TT = idXY;
0129     <span class="keyword">end</span>
0130     tidx=find(posL==k);
0131     tmp(tidx)=TT(tidx).*hiddensurf(tidx);
0132     hiddensurf(tidx)=NaN;
0133     <span class="comment">%imshow(tmp,[0,255]); drawnow(); pause(0.1); % DEBUG code</span>
0134   <span class="keyword">end</span>
0135   imgLids=tmp;
0136   
0137   <span class="comment">%% right image(s)</span>
0138   tmp=NaN*ones(size(randXY));
0139   hiddensurf=ones(size(randXY));
0140   pos=unique(posR(~isnan(posR)))';
0141   <span class="keyword">for</span> k = pos <span class="comment">% from near to far % min(min(posR)):max(max(posR))</span>
0142     <span class="keyword">if</span> k&lt;0
0143       level = size(randXY,2)+k;
0144       TT = [idXY(:,level+1:end) idXY(:,1:level)];
0145     <span class="keyword">elseif</span> k&gt;0
0146       level = k;
0147       TT = [idXY(:,level+1:end) idXY(:,1:level)];
0148     <span class="keyword">elseif</span> k==0
0149       TT = idXY;
0150     <span class="keyword">end</span>
0151     tidx=find(posR==k);
0152     tmp(tidx)=TT(tidx).*hiddensurf(tidx);
0153     hiddensurf(tidx)=NaN;
0154     <span class="comment">%imshow(tmp,[0,255]); drawnow(); pause(0.1); % DEBUG code</span>
0155   <span class="keyword">end</span>
0156   imgRids=tmp;
0157   
0158   <span class="comment">%% replace dots to ovals</span>
0159   <span class="comment">%[comval,Lid,Rid]=intersect(imgLids(:),imgRids(:));</span>
0160   
0161   <span class="comment">%[rowL,colL]=ind2sub(size(imgLids),Lid);</span>
0162   [rowL,colL]=find(~isnan(imgLids));
0163   <span class="keyword">for</span> rr=1:1:size(rowL,1)
0164     <span class="comment">% select white/black dot</span>
0165     <span class="keyword">if</span> mod(imgLids(rowL(rr),colL(rr)),2) <span class="comment">%mod(comval(rr),2)</span>
0166       dot=wdot;
0167     <span class="keyword">else</span>
0168       dot=bdot;
0169     <span class="keyword">end</span>
0170     
0171     <span class="comment">% set ovals to the left image</span>
0172     idxr=max(1,rowL(rr)-round(size(dot,1)/2)+1):min(rowL(rr)+round(size(dot,1)/2),size(imgL{n},1));
0173     idxc=max(1,colL(rr)-round(size(dot,2)/2)+1):min(colL(rr)+round(size(dot,2)/2),size(imgL{n},2));
0174     
0175     <span class="keyword">if</span> 1 &lt;= rowL(rr)-round(size(dot,1)/2)
0176       didxr=1:min(size(dot,1),size(idxr,2));
0177     <span class="keyword">else</span>
0178       <span class="keyword">if</span> rowL(rr)+round(size(dot,1)/2) &lt;= size(imgL{n},1)
0179         didxr=round(size(dot,1)/2)-rowL(rr)+1:size(dot,1);
0180       <span class="keyword">else</span>
0181         didxr=round(size(dot,1)/2)-rowL(rr)+1:size(idxr,1);
0182       <span class="keyword">end</span>
0183     <span class="keyword">end</span>
0184     
0185     <span class="keyword">if</span> 1&lt;=colL(rr)-round(size(dot,2)/2)
0186       didxc=1:min(size(dot,2),size(idxc,2));
0187     <span class="keyword">else</span>
0188       <span class="keyword">if</span> colL(rr)+round(size(dot,2)/2) &lt;= size(imgL{n},2)
0189         didxc=round(size(dot,2)/2)-colL(rr)+1:size(dot,2);
0190       <span class="keyword">else</span>
0191         didxc=round(size(dot,2)/2)-colL(rr)+1:size(idxr,2);
0192       <span class="keyword">end</span>
0193     <span class="keyword">end</span>
0194 
0195     <span class="comment">% put ovals considering alpha value</span>
0196     imgL{n}(idxr,idxc)=(1-dotalpha(didxr,didxc)).*imgL{n}(idxr,idxc)+dotalpha(didxr,didxc).*dot(didxr,didxc);
0197   <span class="keyword">end</span>
0198   
0199   <span class="comment">%[rowR,colR]=ind2sub(size(imgRids),Rid);</span>
0200   [rowR,colR]=find(~isnan(imgRids));
0201   <span class="keyword">for</span> rr=1:1:size(rowR,1)
0202     <span class="comment">% select white/black dot</span>
0203     <span class="keyword">if</span> mod(imgRids(rowR(rr),colR(rr)),2) <span class="comment">%mod(comval(rr),2)</span>
0204       dot=wdot;
0205     <span class="keyword">else</span>
0206       dot=bdot;
0207     <span class="keyword">end</span>
0208     
0209     <span class="comment">% prevent edge removal problem</span>
0210     idxr=max(1,rowR(rr)-round(size(dot,1)/2)+1):min(rowR(rr)+round(size(dot,1)/2),size(imgR{n},1));
0211     idxc=max(1,colR(rr)-round(size(dot,2)/2)+1):min(colR(rr)+round(size(dot,2)/2),size(imgR{n},2));
0212     
0213     <span class="keyword">if</span> 1 &lt;= rowR(rr)-round(size(dot,1)/2)
0214       didxr=1:min(size(dot,1),size(idxr,2));
0215     <span class="keyword">else</span>
0216       <span class="keyword">if</span> rowR(rr)+round(size(dot,1)/2) &lt;= size(imgR{n},1)
0217         didxr=round(size(dot,1)/2)-rowR(rr)+1:size(dot,1);
0218       <span class="keyword">else</span>
0219         didxr=round(size(dot,1)/2)-rowR(rr)+1:size(idxr,1);
0220       <span class="keyword">end</span>
0221     <span class="keyword">end</span>
0222     
0223     <span class="keyword">if</span> 1&lt;=colR(rr)-round(size(dot,2)/2)
0224       didxc=1:min(size(dot,2),size(idxc,2));
0225     <span class="keyword">else</span>
0226       <span class="keyword">if</span> colR(rr)+round(size(dot,2)/2) &lt;= size(imgR{n},2)
0227         didxc=round(size(dot,2)/2)-colR(rr)+1:size(dot,2);
0228       <span class="keyword">else</span>
0229         didxc=round(size(dot,2)/2)-colR(rr)+1:size(idxr,2);
0230       <span class="keyword">end</span>
0231     <span class="keyword">end</span>
0232 
0233     <span class="comment">% put ovals considering alpha value</span>
0234     imgR{n}(idxr,idxc)=(1-dotalpha(didxr,didxc)).*imgR{n}(idxr,idxc)+dotalpha(didxr,didxc).*dot(didxr,didxc);
0235   <span class="keyword">end</span>
0236   
0237   <span class="comment">% adjust oversampled image to the original size</span>
0238   <span class="keyword">if</span> oversampling_ratio~=1
0239     imgL{n}=imresize(uint8(imgL{n}),1/oversampling_ratio,<span class="string">'bilinear'</span>);
0240     imgR{n}=imresize(uint8(imgR{n}),1/oversampling_ratio,<span class="string">'bilinear'</span>);
0241   <span class="keyword">else</span>
0242     imgL{n}=uint8(imgL{n});
0243     imgR{n}=uint8(imgR{n});
0244   <span class="keyword">end</span>
0245   
0246 <span class="keyword">end</span> <span class="comment">% for n=1:1:imgNum</span>
0247 
0248 <span class="comment">% --- plot the results</span>
0249 <span class="keyword">if</span> display_flag
0250   figure; hold on;
0251   <span class="keyword">for</span> n=1:1:imgNum
0252     M = [imgL{n} 127*ones(size(imgL{n},1),20) imgR{n} 127*ones(size(imgL{n},1),20) imgL{n}];
0253     im_h = imagesc(M,[0 255]);
0254     axis off
0255     <span class="comment">% truesize is necessary to avoid automatic scaling</span>
0256     <a href="size_one2one.html" class="code" title="function size_one2one(im_h)">size_one2one</a>(im_h);
0257     colormap(gray);
0258     shg;
0259   <span class="keyword">end</span>
0260 <span class="keyword">end</span>
0261 
0262 <span class="comment">% --- save the results</span>
0263 <span class="keyword">if</span> save_flag
0264   save RDS_imgs.mat imgL imgR posL posR heightfield;
0265 <span class="keyword">end</span>
0266 
0267 <span class="keyword">return</span>;
0268 
0269 <span class="comment">%% subfunction</span>
0270 <a name="_sub1" href="#_subfunctions" class="code">function [Y,index] = shuffle(X)</a>
0271 <span class="comment">% [Y,index] = shuffle(X)</span>
0272 <span class="comment">%</span>
0273 <span class="comment">% Randomly sorts X.</span>
0274 <span class="comment">% If X is a vector, sorts all of X, so Y = X(index).</span>
0275 <span class="comment">% If X is an m-by-n matrix, sorts each column of X, so</span>
0276 <span class="comment">% for j=1:n, Y(:,j)=X(index(:,j),j).</span>
0277 
0278 [null,index] = sort(rand(size(X)));
0279 [n,m] = size(X);
0280 Y = zeros(size(X));
0281 
0282 <span class="keyword">if</span> (n == 1 || m == 1)
0283   Y = X(index);
0284 <span class="keyword">else</span>
0285   <span class="keyword">for</span> j = 1:m
0286     Y(:,j)  = X(index(:,j),j);
0287   <span class="keyword">end</span>
0288 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 10-Jun-2021 10:01:25 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005 using a BVQX_hbtools customized template</address>
</body>
</html>