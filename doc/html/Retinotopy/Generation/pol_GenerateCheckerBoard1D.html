<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of pol_GenerateCheckerBoard1D</title>
  <meta name="keywords" content="pol_GenerateCheckerBoard1D">
  <meta name="description" content="Generates checkerboard patterns (polar angle-based subdivision) with an individual ID number on each patch.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # Retinotopy --><!-- menu.html Generation -->
<h1>pol_GenerateCheckerBoard1D
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Generates checkerboard patterns (polar angle-based subdivision) with an individual ID number on each patch.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [checkerboard,bincheckerboard,mask]=pol_GenerateCheckerBoard1D(rmin,rmax,width,startangle,pix_per_deg,nwedges,nrings,phase,dual_flg) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top"><pre class="comment"> Generates checkerboard patterns (polar angle-based subdivision) with an individual ID number on each patch.
 function [checkerboard,bincheckerboard,mask]=pol_GenerateCheckerBoard1D(:rmin,:rmax,:width,:startangle,:pix_per_deg,:nwedges,:nrings,:phase,:dual_flg)
 (: is optional)

 This function generates checkerboards (polar angle-based subdivision) with an individual ID number on each patch.
 Each of two checkers have the compensating values of its counterpart.
 Multiple start angles are acceptable and will be processed at once, saving computational time.

 [input]
 rmin        : checkerboard's minimum radius in deg, [val], 0 by default.
 rmax        : checkerboard's maximum radius in deg, [val], 6 by default.
 width       : checker width in deg, [val], 48 by default.
 startangle  : checker board start angle, from right horizontal meridian, clockwise
               *** multiple start angles are acceptable ***
               e.g. [0,12,24,36,...], 0 by default.
 pix_per_deg : pixels per degree, [val], 40 by default.
 nwedges     : number of wedges, [val], 4 by default.
 nrings      : number of rings, [val], 8 by default.
 phase       : checker's phase, 0 by default.
 dual_flg    : whether generating a dual-wedge checkerboard pattern [0|1]. 0 by default.
               NOTE: even without proper full polar and eccentricity phase-encoded stimuli,
               from fMRI time series evoked by the checkerboards generated with dual_flg=1
               presented along the horizontal or vertical meridians alternatively, we can
               get reliable landmarks to delineate retinotopy borders along the visual areas.

 [output]
 checkerboard :   output grayscale checkerboard, cell structure, {numel(startangle)}.
                  each pixel shows each checker patch's ID or background(0)
 binchckerboard : (optional) binary (1/2=checker-patterns, 0=background) checkerboard patterns,
                  cell structure, {numel(startangle)}.
 mask           : (optional) checkerboard regional mask, cell structure, logical


 Created    : &quot;2011-04-12 11:12:37 ban&quot;
 Last Update: &quot;2018-12-14 12:30:28 ban&quot;</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top">
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../Retinotopy/Presentation/cdual.html" class="code" title="function cdual(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cdual</a>	Color/luminance-defined checkerboard retinotopy stimulus with checker-patch luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/cdual_fixtask.html" class="code" title="function cdual_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cdual_fixtask</a>	Color/luminance-defined checkerboard retinotopy stimulus with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/chrf.html" class="code" title="function chrf(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">chrf</a>	Color/luminance-defined checkerboard stimulus with checker-patch luminance change-detection tasks for measuring and estimating a HRF function.</li><li><a href="../../Retinotopy/Presentation/chrf_fixtask.html" class="code" title="function chrf_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">chrf_fixtask</a>	Color/luminance-defined checkerboard stimulus with fixation-point luminance change detection tasks for measuring and estimating a HRF function.</li><li><a href="../../Retinotopy/Presentation/clgnlocalizer.html" class="code" title="function clgnlocalizer(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">clgnlocalizer</a>	Color/luminance-defined checkerboard stimulus with checker-patch luminance change-detection tasks, for localizing LGN.</li><li><a href="../../Retinotopy/Presentation/clgnlocalizer_fixtask.html" class="code" title="function clgnlocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">clgnlocalizer_fixtask</a>	Color/luminance-defined checkerboard stimulus with fixation-point luminance change-detection tasks, for localizing LGN.</li><li><a href="../../Retinotopy/Presentation/clocalizer.html" class="code" title="function clocalizer(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">clocalizer</a>	Color/luminance-defined checkerboard stimulus with checkerboard luminance change detection tasks, for localizing specific retinotopic (eccentricity) regions.</li><li><a href="../../Retinotopy/Presentation/clocalizer_fixtask.html" class="code" title="function clocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">clocalizer_fixtask</a>	Color/luminance-defined checkerboard stimulus with central-fixation luminance change detection tasks, for localizing specific retinotopic (iso-eccentricity) regions.</li><li><a href="../../Retinotopy/Presentation/cmeridian.html" class="code" title="function cmeridian(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cmeridian</a>	Color/luminance-defined dual checkerboard stimulus along horizontal/vertical meridians with checker-patch luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/cmeridian_fixtask.html" class="code" title="function cmeridian_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cmeridian_fixtask</a>	Color/luminance-defined dual checkerboard stimulus along horizontal/vertical meridians with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/cretinotopy.html" class="code" title="function cretinotopy(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cretinotopy</a>	Color/luminance-defined checkerboard retinotopy stimulus with checker-patch luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/cretinotopy_fixtask.html" class="code" title="function cretinotopy_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">cretinotopy_fixtask</a>	Color/luminance-defined checkerboard retinotopy stimulus with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dbar.html" class="code" title="function dbar(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dbar</a>	Random-Dot-Stereogram(RDS)-defined checkerboard bar stimulus (pRF) with checker-patch depth change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dbar_fixtask.html" class="code" title="function dbar_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dbar_fixtask</a>	Random-Dot-Stereogram(RDS)-defined checkerboard bar stimulus (pRF) with checker-patch luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/ddual.html" class="code" title="function ddual(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">ddual</a>	Random-Dot-Stereogram(RDS)-defined checkerboard retinotopy stimulus with checker-patch depth change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/ddual_fixtask.html" class="code" title="function ddual_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">ddual_fixtask</a>	Random-Dot-Stereogram(RDS)-defined checkerboard retinotopy stimulus with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dhrf.html" class="code" title="function dhrf(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dhrf</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with checker-patch depth change detection tasks for measuring and estimating a HRF function.</li><li><a href="../../Retinotopy/Presentation/dhrf_fixtask.html" class="code" title="function dhrf_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dhrf_fixtask</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with fixation-point luminance change detection tasks for measuring and estimating a HRF function.</li><li><a href="../../Retinotopy/Presentation/dlgnlocalizer.html" class="code" title="function dlgnlocalizer(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dlgnlocalizer</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with checker-patch depth change-detection tasks, for localizing LGN.</li><li><a href="../../Retinotopy/Presentation/dlgnlocalizer_fixtask.html" class="code" title="function dlgnlocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dlgnlocalizer_fixtask</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with fixation-point luminance change-detection tasks, for localizing LGN.</li><li><a href="../../Retinotopy/Presentation/dlocalizer.html" class="code" title="function dlocalizer(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dlocalizer</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with checker-patch depth change detection tasks, for localizing specific retinotopic (iso-eccentricity) regions.</li><li><a href="../../Retinotopy/Presentation/dlocalizer_fixtask.html" class="code" title="function dlocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dlocalizer_fixtask</a>	Random-Dot-Stereogram(RDS)-defined checkerboard stimulus with central-fixation luminance change detection tasks, for localizing specific retinotopic (iso-eccentricity) regions.</li><li><a href="../../Retinotopy/Presentation/dmeridian.html" class="code" title="function dmeridian(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dmeridian</a>	Random-Dot-Stereogram(RDS)-defined dual checkerboard stimulus along horizontal/vertical meridians with checker-patch depth change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dmeridian_fixtask.html" class="code" title="function dmeridian_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dmeridian_fixtask</a>	Random-Dot-Stereogram(RDS)-defined dual checkerboard stimulus along horizontal/vertical meridians with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dretinotopy.html" class="code" title="function dretinotopy(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dretinotopy</a>	Random-Dot-Stereogram(RDS)-defined stereo checkerboard retinotopy stimulus with checker-patch depth change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/dretinotopy_fixtask.html" class="code" title="function dretinotopy_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">dretinotopy_fixtask</a>	Random-Dot-Stereogram(RDS)-defined stereo checkerboard retinotopy stimulus with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/gen_dual_windows.html" class="code" title="function stim_windows=gen_dual_windows(subjID,exp_mode,acq,displayfile,stimulusfile,overwrite_pix_per_deg,TR)">gen_dual_windows</a>	Generates retinotopy stimulus (polar wedge + eccentricity annulus) windows for pRF (population receptive field) analysis.</li><li><a href="../../Retinotopy/Presentation/gen_retinotopy_windows.html" class="code" title="function stim_windows=gen_retinotopy_windows(subjID,exp_mode,acq,displayfile,stimulusfile,overwrite_pix_per_deg,TR)">gen_retinotopy_windows</a>	Generates retinotopy stimulus (polar/eccentricity) windows for pRF (population receptive field) analysis.</li><li><a href="../../Retinotopy/Presentation/idual_fixtask.html" class="code" title="function idual_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">idual_fixtask</a>	Object-image-defined retinotopy stimulus with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/ihrf_fixtask.html" class="code" title="function ihrf_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">ihrf_fixtask</a>	Object-image-defined checkerboard stimulus with fixation-point luminance change detection tasks for measuring and estimating a HRF function.</li><li><a href="../../Retinotopy/Presentation/ilgnlocalizer_fixtask.html" class="code" title="function ilgnlocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">ilgnlocalizer_fixtask</a>	Object-image-defined wedge stimulus with fixation luminance change-detection tasks, for localizing LGN.</li><li><a href="../../Retinotopy/Presentation/ilocalizer_fixtask.html" class="code" title="function ilocalizer_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">ilocalizer_fixtask</a>	Object-image-defined annulus stimulus with central-fixation luminance change detection tasks, for localizing specific retinotopic (iso-eccentricity) regions.</li><li><a href="../../Retinotopy/Presentation/imeridian_fixtask.html" class="code" title="function imeridian_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">imeridian_fixtask</a>	Object-image-defined dual wedge stimulus along horizontal/vertical meridians with fixation luminance change-detection tasks.</li><li><a href="../../Retinotopy/Presentation/iretinotopy_fixtask.html" class="code" title="function iretinotopy_fixtask(subjID,exp_mode,acq,displayfile,stimulusfile,gamma_table,overwrite_flg,force_proceed_flag)">iretinotopy_fixtask</a>	Object-image-defined retinotopy stimulus with fixation luminance change-detection tasks.</li></ul>
</div>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment" style="background-image:url(../../hb_brain.png); background-position:right top"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [checkerboard,bincheckerboard,mask]=pol_GenerateCheckerBoard1D(rmin,rmax,width,startangle,pix_per_deg,nwedges,nrings,phase,dual_flg)</a>
0002 
0003 <span class="comment">% Generates checkerboard patterns (polar angle-based subdivision) with an individual ID number on each patch.</span>
0004 <span class="comment">% function [checkerboard,bincheckerboard,mask]=pol_GenerateCheckerBoard1D(:rmin,:rmax,:width,:startangle,:pix_per_deg,:nwedges,:nrings,:phase,:dual_flg)</span>
0005 <span class="comment">% (: is optional)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% This function generates checkerboards (polar angle-based subdivision) with an individual ID number on each patch.</span>
0008 <span class="comment">% Each of two checkers have the compensating values of its counterpart.</span>
0009 <span class="comment">% Multiple start angles are acceptable and will be processed at once, saving computational time.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% [input]</span>
0012 <span class="comment">% rmin        : checkerboard's minimum radius in deg, [val], 0 by default.</span>
0013 <span class="comment">% rmax        : checkerboard's maximum radius in deg, [val], 6 by default.</span>
0014 <span class="comment">% width       : checker width in deg, [val], 48 by default.</span>
0015 <span class="comment">% startangle  : checker board start angle, from right horizontal meridian, clockwise</span>
0016 <span class="comment">%               *** multiple start angles are acceptable ***</span>
0017 <span class="comment">%               e.g. [0,12,24,36,...], 0 by default.</span>
0018 <span class="comment">% pix_per_deg : pixels per degree, [val], 40 by default.</span>
0019 <span class="comment">% nwedges     : number of wedges, [val], 4 by default.</span>
0020 <span class="comment">% nrings      : number of rings, [val], 8 by default.</span>
0021 <span class="comment">% phase       : checker's phase, 0 by default.</span>
0022 <span class="comment">% dual_flg    : whether generating a dual-wedge checkerboard pattern [0|1]. 0 by default.</span>
0023 <span class="comment">%               NOTE: even without proper full polar and eccentricity phase-encoded stimuli,</span>
0024 <span class="comment">%               from fMRI time series evoked by the checkerboards generated with dual_flg=1</span>
0025 <span class="comment">%               presented along the horizontal or vertical meridians alternatively, we can</span>
0026 <span class="comment">%               get reliable landmarks to delineate retinotopy borders along the visual areas.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% [output]</span>
0029 <span class="comment">% checkerboard :   output grayscale checkerboard, cell structure, {numel(startangle)}.</span>
0030 <span class="comment">%                  each pixel shows each checker patch's ID or background(0)</span>
0031 <span class="comment">% binchckerboard : (optional) binary (1/2=checker-patterns, 0=background) checkerboard patterns,</span>
0032 <span class="comment">%                  cell structure, {numel(startangle)}.</span>
0033 <span class="comment">% mask           : (optional) checkerboard regional mask, cell structure, logical</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% Created    : &quot;2011-04-12 11:12:37 ban&quot;</span>
0037 <span class="comment">% Last Update: &quot;2018-12-14 12:30:28 ban&quot;</span>
0038 
0039 <span class="comment">%% check the input variables</span>
0040 <span class="keyword">if</span> nargin&lt;1 || isempty(rmin), rmin=0; <span class="keyword">end</span>
0041 <span class="keyword">if</span> nargin&lt;2 || isempty(rmax), rmax=6; <span class="keyword">end</span>
0042 <span class="keyword">if</span> nargin&lt;3 || isempty(width), width=48; <span class="keyword">end</span>
0043 <span class="keyword">if</span> nargin&lt;4 || isempty(startangle), startangle=0; <span class="keyword">end</span>
0044 <span class="keyword">if</span> nargin&lt;5 || isempty(pix_per_deg), pix_per_deg=40; <span class="keyword">end</span>
0045 <span class="keyword">if</span> nargin&lt;6 || isempty(nwedges), nwedges=4; <span class="keyword">end</span>
0046 <span class="keyword">if</span> nargin&lt;7 || isempty(nrings), nrings=8; <span class="keyword">end</span>
0047 <span class="keyword">if</span> nargin&lt;8 || isempty(phase), phase=0; <span class="keyword">end</span>
0048 <span class="keyword">if</span> nargin&lt;9 || isempty(dual_flg), dual_flg=0; <span class="keyword">end</span>
0049 
0050 <span class="comment">%% parameter adjusting</span>
0051 
0052 <span class="comment">% convert deg to pixels</span>
0053 rmin=rmin*pix_per_deg;
0054 rmax=rmax*pix_per_deg;
0055 
0056 <span class="comment">% convert deg to radians</span>
0057 startangle=mod(startangle*pi/180,2*pi);
0058 width=width*pi/180;
0059 <span class="keyword">if</span> phase&gt;width/nwedges, phase=mod(phase,width/nwedges); <span class="keyword">end</span>
0060 phase=phase*pi/180;
0061 
0062 <span class="comment">% add small lim in checkerboard image, this is to avoid unwanted juggy edges</span>
0063 imsize_ratio=1.01;
0064 
0065 
0066 <span class="comment">%% processing</span>
0067 
0068 <span class="comment">% base xy distance field</span>
0069 [xx,yy]=meshgrid((0:1:imsize_ratio*2*rmax)-imsize_ratio*rmax,(0:1:imsize_ratio*2*rmax)-imsize_ratio*rmax);
0070 <span class="comment">%if mod(size(xx,1),2), xx=xx(1:end-1,:); yy=yy(1:end-1,:); end</span>
0071 <span class="comment">%if mod(size(xx,2),2), xx=xx(:,1:end-1); yy=yy(:,1:end-1); end</span>
0072 
0073 <span class="comment">% convert distance field to radians and degree fields</span>
0074 thetafield=mod(atan2(yy,xx),2*pi);
0075 
0076 <span class="comment">% calculate binary class (-1/1) along eccentricity for checkerboard (anuulus)</span>
0077 radii=linspace(rmin,rmax,nrings+1); radii(1)=[]; <span class="comment">% annulus width</span>
0078 r=sqrt(xx.^2+yy.^2); <span class="comment">% radius</span>
0079 cide=zeros(size(xx)); <span class="comment">% checker id, eccentricity</span>
0080 <span class="keyword">for</span> i=length(radii):-1:1
0081   cide(rmin&lt;r &amp; r&lt;=radii(i))=i;
0082 <span class="keyword">end</span>
0083 
0084 <span class="comment">% calculate binary class (-1/1) along polar angle for checkerboard (wedge)</span>
0085 <span class="comment">% and generate checkerboards</span>
0086 checkerboard=cell(numel(startangle),1);
0087 <span class="keyword">if</span> nargout&gt;=2, bincheckerboard=cell(numel(startangle),1); <span class="keyword">end</span>
0088 <span class="keyword">if</span> nargout&gt;=3, mask=cell(numel(startangle),1); <span class="keyword">end</span>
0089 
0090 <span class="keyword">for</span> aa=1:1:numel(startangle)
0091 
0092   <span class="comment">% !!!NOTICE!!!</span>
0093   <span class="comment">% We need to create each checkerboard following the procedures below</span>
0094   <span class="comment">%  1. generate radian angle field</span>
0095   <span class="comment">%  2. rotate it based on startangle &amp; phase</span>
0096   <span class="comment">%  3. generate checkerboard IDs</span>
0097   <span class="comment">% This consumes much CPU power and time, but it is definitely important.</span>
0098   <span class="comment">%</span>
0099   <span class="comment">% To use imrotate after creating one image may look more sophisticated, but we</span>
0100   <span class="comment">% should not do that. This is because when we use imrotate (or fast_rotate)</span>
0101   <span class="comment">% or Screen('DrawTexture',....,rotangle,...), the displayed image will result</span>
0102   <span class="comment">% in low quality with juggy artefact along checker edges.</span>
0103 
0104   done_flag=0;
0105 
0106   <span class="comment">% just flip dimension and copy, if the currect checkerboard is one of</span>
0107   <span class="comment">% 180 deg flipped version of previously generated checkerboards.</span>
0108   <span class="comment">% this is to save calculation time</span>
0109   <span class="keyword">if</span> aa&gt;=2
0110     <span class="keyword">for</span> tt=1:1:aa-1
0111       <span class="comment">%if startangle(aa)==mod(startangle(tt)+pi,2*pi)</span>
0112       <span class="keyword">if</span> abs(startangle(aa)-mod(startangle(tt)+pi,2*pi))&lt;0.01 <span class="comment">% this is to avoid round off error</span>
0113         <span class="comment">%fprintf('#%d checkerboard is generated by just copying/flipping from #%d checkerboard\n',aa,tt); % debug code</span>
0114         checkerboard{aa}=flipdim(flipdim(checkerboard{tt},2),1);
0115         <span class="keyword">if</span> nargout&gt;=2, bincheckerboard{aa}=flipdim(flipdim(bincheckerboard{tt},2),1); <span class="keyword">end</span>
0116         <span class="keyword">if</span> nargout&gt;=3, mask{aa}=flipdim(flipdim(mask{tt},2),1); <span class="keyword">end</span>
0117         done_flag=1;
0118         <span class="keyword">break</span>;
0119       <span class="keyword">end</span>
0120     <span class="keyword">end</span>
0121   <span class="keyword">end</span>
0122 
0123   <span class="keyword">if</span> ~done_flag
0124 
0125     <span class="comment">% calculate inner regions</span>
0126     minlim=startangle(aa);
0127     maxlim=mod(startangle(aa)+width,2*pi);
0128     <span class="keyword">if</span> dual_flg <span class="comment">% dual wedges</span>
0129       <span class="keyword">if</span> minlim==maxlim <span class="comment">% whole annulus</span>
0130         inidx=find( (rmin&lt;=r &amp; r&lt;=rmax) );
0131       <span class="keyword">elseif</span> minlim&gt;maxlim
0132         inidx1=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim&lt;=thetafield &amp; thetafield&lt;2*pi) | (0&lt;=thetafield &amp; thetafield&lt;=maxlim) ) );
0133 
0134         <span class="comment">% generating the second wedge, considering the overflow of the cyclic data (angles)</span>
0135         minlim2=mod(minlim+pi,2*pi);
0136         maxlim2=mod(maxlim+pi,2*pi);
0137         <span class="keyword">if</span> minlim2==maxlim2
0138           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) );
0139         <span class="keyword">elseif</span> minlim2&gt;maxlim2
0140           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim2&lt;=thetafield &amp; thetafield&lt;2*pi) | (0&lt;=thetafield &amp; thetafield&lt;=maxlim2) ) );
0141         <span class="keyword">else</span>
0142           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim2&lt;=thetafield) &amp; (thetafield&lt;=maxlim2) ) );
0143         <span class="keyword">end</span>
0144 
0145         inidx=[inidx1;inidx2];
0146       <span class="keyword">else</span>
0147         inidx1=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim&lt;=thetafield) &amp; (thetafield&lt;=maxlim) ) );
0148 
0149         <span class="comment">% generating the second wedge, considering the overflow of the cyclic data (angles)</span>
0150         minlim2=mod(minlim+pi,2*pi);
0151         maxlim2=mod(maxlim+pi,2*pi);
0152         <span class="keyword">if</span> minlim2==maxlim2
0153           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) );
0154         <span class="keyword">elseif</span> minlim2&gt;maxlim2
0155           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim2&lt;=thetafield &amp; thetafield&lt;2*pi) | (0&lt;=thetafield &amp; thetafield&lt;=maxlim2) ) );
0156         <span class="keyword">else</span>
0157           inidx2=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim2&lt;=thetafield) &amp; (thetafield&lt;=maxlim2) ) );
0158         <span class="keyword">end</span>
0159 
0160         inidx=[inidx1;inidx2];
0161       <span class="keyword">end</span>
0162     <span class="keyword">else</span> <span class="comment">% if ~dual_flg : a single wedge</span>
0163       <span class="keyword">if</span> minlim==maxlim <span class="comment">% whole annulus</span>
0164         inidx=find( (rmin&lt;=r &amp; r&lt;=rmax) );
0165       <span class="keyword">elseif</span> minlim&gt;maxlim
0166         inidx=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim&lt;=thetafield &amp; thetafield&lt;2*pi) | (0&lt;=thetafield &amp; thetafield&lt;=maxlim) ) );
0167       <span class="keyword">else</span>
0168         inidx=find( (rmin&lt;=r &amp; r&lt;=rmax) &amp; ( (minlim&lt;=thetafield) &amp; (thetafield&lt;=maxlim) ) );
0169       <span class="keyword">end</span>
0170     <span class="keyword">end</span>
0171 
0172     <span class="comment">% calculate wedge IDs</span>
0173     th=thetafield(inidx)-startangle(aa)+phase;
0174     th=mod(th,2*pi);
0175     cidp=zeros(size(thetafield));
0176     cidp(inidx)=ceil(th/width*nwedges); <span class="comment">% checker id, polar angle</span>
0177 
0178     <span class="comment">% correct wedge IDs</span>
0179     <span class="keyword">if</span> phase~=0 <span class="comment">%mod(phase,width/nwedges)~=0</span>
0180       cidp(inidx)=mod(cidp(inidx)-(2*pi/(width/nwedges)-1),2*pi/(width/nwedges))+1;
0181       minval=unique(cidp); minval=minval(2); <span class="comment">% not 1 because the first value is 0 = background;</span>
0182       cidp(cidp&gt;0)=cidp(cidp&gt;0)-minval+1;
0183       true_nwedges=numel(unique(cidp))-1; <span class="comment">% -1 is to omit 0 = background;</span>
0184     <span class="keyword">else</span>
0185       true_nwedges=nwedges;
0186     <span class="keyword">end</span>
0187 
0188     <span class="comment">% generate checker's ID</span>
0189     checkerboard{aa}=zeros(size(thetafield));
0190     checkerboard{aa}(inidx)=cidp(inidx)+(cide(inidx)-1)*true_nwedges;
0191 
0192     <span class="comment">% exclude outliers</span>
0193     <span class="comment">%checkerboard{aa}(r&lt;rmin | rmax&lt;r)=0;</span>
0194     checkerboard{aa}(checkerboard{aa}&lt;0)=0;
0195 
0196     <span class="comment">% generate a binary (1/2=checker-patterns and 0=background) checkerboard</span>
0197     <span class="keyword">if</span> nargout&gt;=2
0198       <span class="keyword">if</span> dual_flg &amp;&amp; minlim~=maxlim <span class="comment">% dual wedges</span>
0199         rings=zeros(size(cide));
0200         rings(inidx1)=2*mod(cide(inidx1),2)-1; <span class="comment">% -1/1 class</span>
0201         rings(inidx2)=-1.*(2*mod(cide(inidx2),2)-1); <span class="comment">% 1/-1 class</span>
0202       <span class="keyword">else</span> <span class="comment">% if ~dual_flg : a single wedge</span>
0203         rings=zeros(size(cide));
0204         rings(inidx)=2*mod(cide(inidx),2)-1; <span class="comment">% -1/1 class</span>
0205       <span class="keyword">end</span>
0206 
0207       wedges=zeros(size(cidp));
0208       wedges(inidx)=2*mod(cidp(inidx),2)-1; <span class="comment">% -1/1 class</span>
0209 
0210       bincheckerboard{aa}=zeros(size(thetafield));
0211       bincheckerboard{aa}(inidx)=wedges(inidx).*rings(inidx);
0212       bincheckerboard{aa}(r&gt;rmax)=0;
0213       bincheckerboard{aa}(bincheckerboard{aa}&lt;0)=2;
0214     <span class="keyword">end</span>
0215 
0216     <span class="comment">% generate mask</span>
0217     <span class="keyword">if</span> nargout&gt;=3, mask{aa}=logical(checkerboard{aa}); <span class="keyword">end</span>
0218 
0219   <span class="keyword">end</span> <span class="comment">% if ~done_flag</span>
0220 
0221 <span class="keyword">end</span> <span class="comment">% for aa=1:1:numel(startangle)</span>
0222 
0223 <span class="keyword">return</span></pre></div>
<hr><address>Generated on Wed 09-Jun-2021 14:56:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005 using a BVQX_hbtools customized template</address>
</body>
</html>